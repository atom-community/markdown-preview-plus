{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./src-client/update-preview.ts","./node_modules/morphdom/dist/morphdom-esm.js","./src-client/diff.ts","./src-client/util.ts","./src-client/mathjax-helper.ts","./src/util-common.ts","./src-client/main.ts"],"sourcesContent":["var $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$export(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n","import morph from 'morphdom'\nimport { MathJaxController } from './mathjax-helper'\nimport { diff } from './diff'\nimport { TDiffMethod } from './ipc'\n\nfunction isEqualMath(a: Node, b: Node) {\n  const tcs = getMathContents(a, b)\n  return tcs && tcs[0].textContent === tcs[1].textContent\n}\n\nfunction getMathContents(a: Node, b: Node) {\n  if (!isElement(a) || !isElement(b)) return false\n  if (\n    a.tagName !== 'SPAN' ||\n    b.tagName !== 'SPAN' ||\n    !a.classList.contains('math') ||\n    !b.classList.contains('math')\n  ) {\n    return false\n  }\n  const ascr = a.querySelector<HTMLScriptElement>(':scope > script')\n  if (!ascr) return false\n  const bscr = b.querySelector<HTMLScriptElement>(':scope > script')\n  if (!bscr) return false\n  if (ascr.type !== bscr.type) return false\n  return [ascr, bscr] as const\n}\n\nfunction isElement(a: Node): a is Element {\n  return a.nodeType === Node.ELEMENT_NODE\n}\n\nfunction checkDocumentType(a: DocumentType, b: DocumentType) {\n  return (\n    a.name === b.name && a.publicId === b.publicId && a.systemId === b.systemId\n  )\n}\n\nfunction checkElement(a: Element, b: Element) {\n  if (a.attributes.length !== b.attributes.length) return false\n  return Array.from(a.attributes).every((x) =>\n    x.isEqualNode(b.attributes.getNamedItemNS(x.namespaceURI, x.localName)),\n  )\n}\n\nfunction checkAttr(a: Attr, b: Attr) {\n  return (\n    a.namespaceURI === b.namespaceURI &&\n    a.localName === b.localName &&\n    a.value === b.value\n  )\n}\n\nfunction checkProcInstr(a: ProcessingInstruction, b: ProcessingInstruction) {\n  return a.target === b.target && a.data === b.data\n}\n\nfunction checkData(a: { data: string }, b: { data: string }) {\n  return a.data === b.data\n}\n\n// based on https://dom.spec.whatwg.org/#concept-node-equals\nfunction isEqual(a: Node, b: Node): boolean {\n  // early bailouts\n  if (a.isEqualNode(b)) return true\n  if (isEqualMath(a, b)) return true\n\n  // node checks\n  if (a.nodeType !== b.nodeType) return false\n  if (a.childNodes.length !== b.childNodes.length) return false\n\n  // recursively check children\n  let ac = a.firstChild\n  let bc = b.firstChild\n  while (ac && bc) {\n    if (!isEqual(ac, bc)) return false\n    ac = ac.nextSibling\n    bc = bc.nextSibling\n  }\n\n  switch (a.nodeType) {\n    case Node.DOCUMENT_TYPE_NODE:\n      return checkDocumentType(a as DocumentType, b as DocumentType)\n    case Node.ELEMENT_NODE:\n      return checkElement(a as Element, b as Element)\n    case Node.ATTRIBUTE_NODE:\n      return checkAttr(a as Attr, b as Attr)\n    case Node.PROCESSING_INSTRUCTION_NODE:\n      return checkProcInstr(\n        a as ProcessingInstruction,\n        b as ProcessingInstruction,\n      )\n    case Node.TEXT_NODE:\n    case Node.COMMENT_NODE:\n      return checkData(a as Text | Comment, b as Text | Comment)\n    default:\n      return true\n  }\n}\n\nfunction* allChildren(node: Element): IterableIterator<Element> {\n  for (const c of node.children) {\n    if (c.tagName === 'SPAN' && c.classList.contains('MathJax')) continue\n    if (c.tagName === 'SPAN' && c.classList.contains('MathJax_SVG')) continue\n    if (c.tagName === 'SCRIPT') continue\n    if (c.tagName === 'DIV' && c.classList.contains('MathJax_Display')) continue\n    if (c.tagName === 'DIV' && c.classList.contains('MathJax_SVG_Display')) {\n      continue\n    }\n    yield c\n    if (c.tagName === 'PRE' && c.classList.contains('editor-colors')) continue\n    yield* allChildren(c)\n  }\n}\n\nfunction runHeuristic(\n  idMap: WeakMap<Node, string>,\n  newDom: Element,\n  oldDom: Element,\n): void {\n  let idx = 0\n  // pre-match nodes in both trees\n  function matchEls(newRoot: Node, oldRoot: Node) {\n    let newEl = newRoot.firstChild\n    let oldEl = oldRoot.firstChild\n    const newCount = newRoot.childNodes.length\n    const oldCount = oldRoot.childNodes.length\n    if (newCount > oldCount) {\n      // checking for insertions\n      while (oldEl && newEl) {\n        if (isEqual(newEl, oldEl)) {\n          if (newEl.nodeType === Node.ELEMENT_NODE) {\n            const sidx = idx.toString(36)\n            idMap.set(oldEl, sidx)\n            idMap.set(newEl, sidx)\n            idx++\n          }\n          matchEls(newEl, oldEl)\n          oldEl = oldEl.nextSibling\n        }\n        newEl = newEl.nextSibling\n      }\n    } else if (newCount < oldCount) {\n      // checking for deletions\n      while (oldEl && newEl) {\n        if (isEqual(newEl, oldEl)) {\n          if (newEl.nodeType === Node.ELEMENT_NODE) {\n            const sidx = idx.toString(36)\n            idMap.set(oldEl, sidx)\n            idMap.set(newEl, sidx)\n            idx++\n          }\n          matchEls(newEl, oldEl)\n          newEl = newEl.nextSibling\n        }\n        oldEl = oldEl.nextSibling\n      }\n    }\n  }\n  matchEls(newDom, oldDom)\n}\n\nfunction time<T>(cb: () => T): T {\n  const start = performance.now()\n  const res = cb()\n  console.log(cb.toString(), performance.now() - start, 'ms')\n  return res\n}\nexport async function update(\n  oldDom: Element,\n  newDom: Element,\n  opts: {\n    mjController: MathJaxController\n    renderLaTeX: boolean\n    diffMethod: TDiffMethod\n  },\n): Promise<void> {\n  const idMap = new WeakMap<Node, string>()\n  switch (opts.diffMethod) {\n    case 'heuristic': {\n      time(() => runHeuristic(idMap, newDom, oldDom))\n      break\n    }\n    case 'myers': {\n      const a = time(() => Array.from(allChildren(oldDom)))\n      const b = time(() => Array.from(allChildren(newDom)))\n      let ncomp = 0\n      let idx = 0\n      time(() =>\n        diff(\n          a,\n          b,\n          (a, b) => {\n            ncomp++\n            return isEqual(a, b)\n          },\n          (pairs) => {\n            for (const [x, y] of pairs) {\n              const sidx = idx.toString(36)\n              idMap.set(x, sidx)\n              idMap.set(y, sidx)\n              idx++\n            }\n          },\n        ),\n      )\n      console.log('a:', a.length, 'b:', b.length, 'comp:', ncomp)\n      break\n    }\n    case 'none':\n      break\n  }\n\n  try {\n    morph(oldDom, newDom, {\n      childrenOnly: true,\n      onBeforeElUpdated(fromEl, toEl) {\n        if (fromEl.isEqualNode(toEl)) return false\n        const tcs = getMathContents(fromEl, toEl)\n        if (tcs) {\n          if (tcs[0].textContent !== tcs[1].textContent) {\n            tcs[0].textContent = tcs[1].textContent\n          }\n          return false\n        }\n        return true\n      },\n      getNodeKey(node: Element) {\n        return idMap.get(node) || ''\n      },\n    })\n  } catch (e) {\n    console.error(e)\n    oldDom.innerHTML = newDom.innerHTML\n  }\n\n  if (opts.renderLaTeX) await opts.mjController.queueTypeset(oldDom)\n}\n","var DOCUMENT_FRAGMENT_NODE = 11;\n\nfunction morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // document-fragments dont have attributes so lets not do anything\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    // update attributes on original DOM element\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n        attr = toNodeAttrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                if (attr.prefix === 'xmlns'){\n                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix\n                }\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n        attr = fromNodeAttrs[d];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n\n            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n            }\n        } else {\n            if (!toNode.hasAttribute(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();\n\nfunction createFragmentFromTemplate(str) {\n    var template = doc.createElement('template');\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n}\n\nfunction createFragmentFromRange(str) {\n    if (!range) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n}\n\nfunction createFragmentFromWrap(str) {\n    var fragment = doc.createElement('body');\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n}\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n    str = str.trim();\n    if (HAS_TEMPLATE_SUPPORT) {\n      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which\n      // createContextualFragment doesn't support\n      // <template> support not available in IE\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    // If the target element is a virtual DOM node or SVG node then we may\n    // need to normalize the tag name before comparing. Normal HTML elements that are\n    // in the \"http://www.w3.org/1999/xhtml\"\n    // are converted to upper case\n    if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower\n        return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower\n        return toNodeName === fromNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE$1 = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n  if (node) {\n      return (node.getAttribute && node.getAttribute('id')) || node.id;\n  }\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = Object.create(null);\n        var keyedRemovalList = [];\n\n        function addKeyedRemoval(key) {\n            keyedRemovalList.push(key);\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    // if we find a duplicate #id node in cache, replace `el` with cache value\n                    // and morph it to the child node.\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphEl(unmatchedFromEl, curChild);\n                    } else {\n                      handleNodeAdded(curChild);\n                    }\n                } else {\n                  // recursively call for curChild and it's children to see if we find something in\n                  // fromNodesLookup\n                  handleNodeAdded(curChild);\n                }\n\n                curChild = nextSibling;\n            }\n        }\n\n        function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n            // We have processed all of the \"to nodes\". If curFromNodeChild is\n            // non-null then we still have some from nodes left over that need\n            // to be removed\n            while (curFromNodeChild) {\n                var fromNextSibling = curFromNodeChild.nextSibling;\n                if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                    // Since the node is keyed it might be matched up later so we defer\n                    // the actual removal to later\n                    addKeyedRemoval(curFromNodeKey);\n                } else {\n                    // NOTE: we skip nested keyed nodes from being removed since there is\n                    //       still a chance they will be matched up later\n                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                }\n                curFromNodeChild = fromNextSibling;\n            }\n        }\n\n        function morphEl(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (!childrenOnly) {\n                // optional\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                // update attributes on original DOM element first\n                morphAttrs(fromEl, toEl);\n                // optional\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n              morphChildren(fromEl, toEl);\n            } else {\n              specialElHandlers.TEXTAREA(fromEl, toEl);\n            }\n        }\n\n        function morphChildren(fromEl, toEl) {\n            var curToNodeChild = toEl.firstChild;\n            var curFromNodeChild = fromEl.firstChild;\n            var curToNodeKey;\n            var curFromNodeKey;\n\n            var fromNextSibling;\n            var toNextSibling;\n            var matchingFromEl;\n\n            // walk the children\n            outer: while (curToNodeChild) {\n                toNextSibling = curToNodeChild.nextSibling;\n                curToNodeKey = getNodeKey(curToNodeChild);\n\n                // walk the fromNode children all the way through\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n\n                    if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                    var curFromNodeType = curFromNodeChild.nodeType;\n\n                    // this means if the curFromNodeChild doesnt have a match with the curToNodeChild\n                    var isCompatible = undefined;\n\n                    if (curFromNodeType === curToNodeChild.nodeType) {\n                        if (curFromNodeType === ELEMENT_NODE) {\n                            // Both nodes being compared are Element nodes\n\n                            if (curToNodeKey) {\n                                // The target node has a key so we want to match it up with the correct element\n                                // in the original DOM tree\n                                if (curToNodeKey !== curFromNodeKey) {\n                                    // The current element in the original DOM tree does not have a matching key so\n                                    // let's check our lookup to see if there is a matching element in the original\n                                    // DOM tree\n                                    if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                        if (fromNextSibling === matchingFromEl) {\n                                            // Special case for single element removals. To avoid removing the original\n                                            // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                            // we will instead discard the current node and wait until the next\n                                            // iteration to properly match up the keyed target element with its matching\n                                            // element in the original tree\n                                            isCompatible = false;\n                                        } else {\n                                            // We found a matching keyed element somewhere in the original DOM tree.\n                                            // Let's move the original DOM node into the current position and morph\n                                            // it.\n\n                                            // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                            // the `removeNode()` function for the node that is being discarded so that\n                                            // all lifecycle hooks are correctly invoked\n                                            fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                            // fromNextSibling = curFromNodeChild.nextSibling;\n\n                                            if (curFromNodeKey) {\n                                                // Since the node is keyed it might be matched up later so we defer\n                                                // the actual removal to later\n                                                addKeyedRemoval(curFromNodeKey);\n                                            } else {\n                                                // NOTE: we skip nested keyed nodes from being removed since there is\n                                                //       still a chance they will be matched up later\n                                                removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                            }\n\n                                            curFromNodeChild = matchingFromEl;\n                                        }\n                                    } else {\n                                        // The nodes are not compatible since the \"to\" node has a key and there\n                                        // is no matching keyed node in the source tree\n                                        isCompatible = false;\n                                    }\n                                }\n                            } else if (curFromNodeKey) {\n                                // The original has a key\n                                isCompatible = false;\n                            }\n\n                            isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                            if (isCompatible) {\n                                // We found compatible DOM elements so transform\n                                // the current \"from\" node to match the current\n                                // target DOM node.\n                                // MORPH\n                                morphEl(curFromNodeChild, curToNodeChild);\n                            }\n\n                        } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                            // Both nodes being compared are Text or Comment nodes\n                            isCompatible = true;\n                            // Simply update nodeValue on the original node to\n                            // change the text value\n                            if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                            }\n\n                        }\n                    }\n\n                    if (isCompatible) {\n                        // Advance both the \"to\" child and the \"from\" child since we found a match\n                        // Nothing else to do as we already recursively called morphChildren above\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    // No compatible match so remove the old node from the DOM and continue trying to find a\n                    // match in the original DOM. However, we only do this if the from node is not keyed\n                    // since it is possible that a keyed node might match up with a node somewhere else in the\n                    // target tree and we don't want to discard it just yet since it still might find a\n                    // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                    // that didn't find a home\n                    if (curFromNodeKey) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n\n                    curFromNodeChild = fromNextSibling;\n                } // END: while(curFromNodeChild) {}\n\n                // If we got this far then we did not find a candidate match for\n                // our \"to node\" and we exhausted all of the children \"from\"\n                // nodes. Therefore, we will just append the current \"to\" node\n                // to the end\n                if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                    fromEl.appendChild(matchingFromEl);\n                    // MORPH\n                    morphEl(matchingFromEl, curToNodeChild);\n                } else {\n                    var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                    if (onBeforeNodeAddedResult !== false) {\n                        if (onBeforeNodeAddedResult) {\n                            curToNodeChild = onBeforeNodeAddedResult;\n                        }\n\n                        if (curToNodeChild.actualize) {\n                            curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                        }\n                        fromEl.appendChild(curToNodeChild);\n                        handleNodeAdded(curToNodeChild);\n                    }\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n            }\n\n            cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphChildren(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    if (morphedNode.nodeValue !== toNode.nodeValue) {\n                        morphedNode.nodeValue = toNode.nodeValue;\n                    }\n\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n                return;\n            }\n\n            morphEl(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nexport default morphdom;\n","//  This code is ported from\n//  <https://github.com/RobertElderSoftware/roberteldersoftwarediff/>\n//\n//  The license for the original code is:\n//\n//  Copyright 2017 Robert Elder Software Inc.\n//\n//  Licensed under the Apache License, Version 2.0 (the \"License\");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an \"AS IS\" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.import random\n\nimport { zip } from './util'\n\nexport function diff<T, U>(\n  left: ArrayLike<T>,\n  right: ArrayLike<U>,\n  compare: (t: T, u: U) => boolean,\n  match: (pairs: Iterable<[T, U]>) => void,\n): void {\n  const slices: [any[], any[]][] = []\n  function go(e: Array<T>, f: Array<U>, i = 0, j = 0): void {\n    // Adapted from http://blog.robertelder.org/diff-algorithm/\n    // Licensed under Apache 2.0\n    const [N, M, L, Z] = [\n      e.length,\n      f.length,\n      e.length + f.length,\n      2 * Math.min(e.length, f.length) + 2,\n    ]\n    if (N > 0 && M > 0) {\n      const [w, g, p] = [\n        N - M,\n        Array(Z).fill(0) as number[],\n        Array(Z).fill(0) as number[],\n      ]\n      for (let h = 0; h < L / 2 + (L % 2) + 1; h++) {\n        for (let r = 0; r < 2; r++) {\n          const [c, d, o, m] = r === 0 ? [g, p, 1, 1] : [p, g, 0, -1]\n          for (\n            let k = -(h - 2 * Math.max(0, h - M));\n            k < h - 2 * Math.max(0, h - N) + 1;\n            k += 2\n          ) {\n            let a =\n              k === -h || (k !== h && c[(k - 1) % Z] < c[(k + 1) % Z])\n                ? c[(k + 1) % Z]\n                : c[(k - 1) % Z] + 1\n            let b = a - k\n            const [s, t] = [a, b]\n            while (\n              a < N &&\n              b < M &&\n              compare(\n                e[(1 - o) * N + m * a + (o - 1)],\n                f[(1 - o) * M + m * b + (o - 1)],\n              )\n            ) {\n              a++, b++\n            }\n            c[k % Z] = a\n            const z = -(k - w)\n            if (\n              L % 2 === o &&\n              z >= -(h - o) &&\n              z <= h - o &&\n              c[k % Z] + d[z % Z] >= N\n            ) {\n              const [D, x, y, u, v] =\n                o === 1\n                  ? [2 * h - 1, s, t, a, b]\n                  : [2 * h, N - a, M - b, N - s, M - t]\n              if (D > 1 || (x !== u && y !== v)) {\n                if (x !== u && y !== v) {\n                  slices.push([e.slice(x, u), f.slice(y, v)])\n                }\n                // return go(e.slice(0, x), f.slice(0, y), i, j).concat(\n                //   go(e.slice(u, N), f.slice(v, M), i + u, j + v),\n                go(e.slice(0, x), f.slice(0, y), i, j)\n                go(e.slice(u, N), f.slice(v, M), i + u, j + v)\n                return\n              } else if (M > N) {\n                slices.push([e.slice(0, N), f.slice(0, N)])\n                return\n                // return go([], f.slice(N, M), i + N, j + N)\n              } else if (M < N) {\n                slices.push([e.slice(0, M), f.slice(0, M)])\n                return\n                // return go(e.slice(M, N), [], i + M, j + M)\n              } // else return []\n            }\n          }\n        }\n      }\n    } /* else if (N > 0) {\n      console.log('delete', e)\n      return\n    } else {\n      console.log('insert', e)\n    }*/\n  }\n  go(Array.from(left), Array.from(right))\n  match(slicesToItems(slices))\n}\n\nfunction* slicesToItems(slices: [any[], any[]][]) {\n  for (const [a, b] of slices) {\n    yield* zip(a, b)\n  }\n}\n","export function handlePromise(promise: Promise<any>): void {\n  if (!promise) return\n  promise.catch((error: Error) => {\n    console.error(error)\n  })\n}\nimport { lstatSync, existsSync } from 'fs'\nexport function isFileSync(filePath: string) {\n  if (!existsSync(filePath)) return false\n  return lstatSync(filePath).isFile()\n}\n\nexport function resolveElement(\n  root: Element,\n  pathToToken: Array<{ tag: string; index: number }>,\n): Element | undefined {\n  let element = root\n  for (const token of pathToToken) {\n    const candidateElement: HTMLElement | null = element\n      .querySelectorAll(`:scope > ${token.tag}`)\n      .item(token.index) as HTMLElement\n    if (candidateElement) {\n      element = candidateElement\n    } else {\n      break\n    }\n  }\n\n  if (element === root) return undefined // Do not jump to the top of the preview for bad syncs\n  return element\n}\n\nexport function* zip<U, V>(\n  a: Iterable<U>,\n  b: Iterable<V>,\n): IterableIterator<[U, V]> {\n  const ita = a[Symbol.iterator]()\n  const itb = b[Symbol.iterator]()\n  let x = ita.next()\n  let y = itb.next()\n  while (!x.done && !y.done) {\n    yield [x.value, y.value]\n    x = ita.next()\n    y = itb.next()\n  }\n}\n","//\n// mathjax-helper\n//\n// This module will handle loading the MathJax environment and provide a wrapper\n// for calls to MathJax to process LaTeX equations.\n//\n\nexport function processHTMLString(element: Element) {\n  const msvgh = document.getElementById('MathJax_SVG_Hidden')\n  const svgGlyphs = msvgh && msvgh.parentElement\n  if (svgGlyphs !== null) {\n    return svgGlyphs.outerHTML + element.innerHTML\n  } else {\n    return element.innerHTML\n  }\n}\n\nexport class MathJaxController {\n  private static mjSrc = `${global.require.resolve(\n    'mathjax',\n  )}?delayStartupUntil=configured`\n  private readonly readyPromise: Promise<void>\n\n  private constructor(\n    private userMacros: object,\n    private mathJaxConfig: MathJaxConfig,\n  ) {\n    this.readyPromise = this.attachMathJax()\n  }\n\n  public static async create(userMacros: object, mathJaxConfig: MathJaxConfig) {\n    const controller = new MathJaxController(userMacros, mathJaxConfig)\n    await controller.readyPromise\n    return controller\n  }\n\n  // for testing\n  public dispose(): void {\n    const script = document.head!.querySelector(\n      `script[src='${MathJaxController.mjSrc}']`,\n    )\n    if (script) script.remove()\n  }\n\n  public jaxTeXConfig() {\n    return {\n      extensions: this.mathJaxConfig.texExtensions,\n      Macros: this.userMacros,\n      equationNumbers: this.mathJaxConfig.numberEquations\n        ? {\n            autoNumber: 'AMS',\n            useLabelIds: false,\n          }\n        : {},\n    }\n  }\n\n  public async queueTypeset(domElement: Element) {\n    const allMath = Array.from(\n      domElement.querySelectorAll('span.math > script[type^=\"math/tex\"]'),\n    )\n    const unprocessedMath = allMath.filter((x) => {\n      const jax = MathJax.Hub.getJaxFor(x) as MathJax.ElementJax | null\n      try {\n        return !jax || x.id !== jax.inputID || jax.needsUpdate()\n      } catch (e) {\n        console.error(e)\n        return true\n      }\n    })\n    if (unprocessedMath.length === 0) return\n    return new Promise<void>((resolve) => {\n      if (MathJax.InputJax.TeX) {\n        MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX])\n      }\n      const { temps, spans } = this.setupTemps(allMath)\n      MathJax.Hub.Queue(['PreProcess', MathJax.Hub, temps])\n      MathJax.Hub.Queue(['Reprocess', MathJax.Hub, temps])\n      MathJax.Hub.Queue(() => this.cleanupTemps(temps, spans))\n      MathJax.Hub.Queue([resolve])\n    })\n  }\n\n  private cleanupTemps(temps: HTMLElement[], spans: HTMLElement[]) {\n    for (const span of spans) span.remove()\n    for (const temp of temps) {\n      temp.style.visibility = ''\n      temp.style.position = ''\n      temp.style.width = ''\n      temp.style.display = ''\n      temp.classList.remove('temp-MathJax')\n    }\n  }\n\n  private setupTemps(scriptElements: Element[]) {\n    const temps: HTMLElement[] = []\n    const spans: HTMLElement[] = []\n    for (const script of scriptElements) {\n      const span = script.parentElement\n      if (!span) continue\n      const par = span.parentElement\n      if (!par) continue\n      const disp = script.previousElementSibling\n      if (disp) {\n        // update render\n        const temp = span.cloneNode(false) as HTMLSpanElement\n        temp.classList.add('temp-MathJax')\n        temp.appendChild(script.cloneNode(true))\n        temps.push(temp)\n        spans.push(span)\n        par.insertBefore(temp, span)\n        temp.style.visibility = 'hidden'\n        temp.style.position = 'absolute'\n        if ((script as HTMLScriptElement).type.includes('display')) {\n          temp.style.width = window.getComputedStyle(disp).width\n          temp.style.display = 'block'\n        }\n      } else {\n        // initial render\n        temps.push(span)\n      }\n    }\n    return { temps, spans }\n  }\n\n  private async attachMathJax(): Promise<void> {\n    // Attach MathJax script\n    await injectScript(MathJaxController.mjSrc)\n\n    MathJax.Hub.Config({\n      jax: ['input/TeX', `output/${this.mathJaxConfig.latexRenderer}`],\n      extensions: [],\n      TeX: this.jaxTeXConfig(),\n      'HTML-CSS': {\n        availableFonts: [],\n        webFont: 'TeX',\n        imageFont: null as any, // TODO: complain on DT\n        undefinedFamily: this.mathJaxConfig.undefinedFamily as any, // TODO: complain on DT\n        mtextFontInherit: true,\n      },\n      messageStyle: 'none',\n      showMathMenu: false,\n      skipStartupTypeset: true,\n    })\n    MathJax.Hub.Configured()\n  }\n}\n\nasync function injectScript(scriptSrc: string) {\n  const script = document.createElement('script')\n  script.src = scriptSrc\n  script.type = 'text/javascript'\n  document.head!.appendChild(script)\n  return new Promise<void>((resolve) => {\n    script.addEventListener('load', () => resolve())\n  })\n}\n","export function getMedia(document: HTMLDocument) {\n  return document.querySelectorAll(\n    'img[src],audio[src],video[src],link[href]',\n  ) as NodeListOf<\n    HTMLImageElement | HTMLAudioElement | HTMLVideoElement | HTMLLinkElement\n  >\n}\n","import { ipcRenderer } from 'electron'\nimport { update } from './update-preview'\nimport { MathJaxController, processHTMLString } from './mathjax-helper'\nimport * as util from './util'\nimport { getMedia } from '../src/util-common'\nimport { ChannelMap } from './ipc'\n\nlet handlerId: number\nlet nativePageScrollKeys = false\n\nfunction uncaughtError(err: Error) {\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-uncaught-error'>(\n    'atom-markdown-preview-plus-ipc-uncaught-error',\n    handlerId,\n    {\n      message: err.message,\n      name: err.name,\n      stack: err.stack,\n    },\n  )\n}\n\nwindow.addEventListener('error', (e) => {\n  uncaughtError(e.error as Error)\n})\n\nwindow.addEventListener('unhandledrejection', (evt) => {\n  uncaughtError((evt as any).reason as Error)\n})\n\nfunction mkResPromise<T>() {\n  let resFn: (value: T | PromiseLike<T>) => void\n  const p = new Promise<T>((resolve) => (resFn = resolve)) as Promise<T> & {\n    resolve: typeof resFn\n  }\n  p.resolve = resFn!\n  return p\n}\n\nconst atomVars = {\n  mathJax: mkResPromise<MathJaxController>(),\n  sourceLineMap: new Map<number, Element>(),\n  revSourceMap: new WeakMap<Element, number[]>(),\n}\n\nipcRenderer.on<'set-id'>('set-id', (_evt, id) => {\n  handlerId = id\n})\n\nipcRenderer.on<'init'>('init', (_evt, params) => {\n  atomVars.mathJax.resolve(\n    MathJaxController.create(params.userMacros, params.mathJaxConfig),\n  )\n  document.documentElement!.dataset.markdownPreviewPlusContext = params.context\n  // tslint:disable-next-line:totality-check\n  if (params.context === 'pdf-export') {\n    document.documentElement!.style.setProperty(\n      'width',\n      `${params.pdfExportOptions.width}mm`,\n      'important',\n    )\n  }\n})\n\nipcRenderer.on<'set-native-keys'>('set-native-keys', (_evt, val) => {\n  nativePageScrollKeys = val\n})\n\nfunction scrollSync({ firstLine, lastLine }: ChannelMap['scroll-sync']) {\n  if (firstLine === 0) {\n    window.scroll({ top: 0 })\n    return\n  }\n  const slm = atomVars.sourceLineMap\n  const lines = Array.from(slm.keys()).sort((a, b) => a - b)\n  let lowix = lines.findIndex((x) => x >= firstLine)\n  if (lowix > 0) lowix--\n  let highix = lines.findIndex((x) => x >= lastLine)\n  if (highix === -1) highix = lines.length - 1\n  else if (highix < lines.length - 1) highix++\n  const low = lines[lowix]\n  const high = lines[highix]\n  let norm = 0\n  let meanScroll = 0\n  const entries = Array.from(slm.entries()).slice(lowix, highix + 1)\n  for (const [line, item] of entries) {\n    const weight = line <= (high + low) / 2 ? line - low + 1 : high - line + 1\n    norm += weight\n    meanScroll += item.getBoundingClientRect().top * weight\n  }\n  if (norm === 0) return\n  const offset = document.documentElement!.scrollTop\n  const clientHeight = document.documentElement!.clientHeight\n  const top = offset - clientHeight / 2 + meanScroll / norm\n  window.scroll({ top })\n}\n\nipcRenderer.on<'scroll-sync'>('scroll-sync', (_evt, params) => {\n  scrollSync(params)\n})\n\nipcRenderer.on<'style'>('style', (_event, { styles }) => {\n  let styleElem = document.head!.querySelector('style#atom-styles')\n  if (!styleElem) {\n    styleElem = document.createElement('style')\n    styleElem.id = 'atom-styles'\n    document.head!.appendChild(styleElem)\n  }\n  styleElem.innerHTML = styles.join('\\n')\n})\n\nipcRenderer.on<'update-images'>('update-images', (_event, { oldsrc, v }) => {\n  const imgs = getMedia(document)\n  for (const img of Array.from(imgs)) {\n    let ovs: string | undefined\n    let ov: number | undefined\n    let attrName: 'href' | 'src'\n    if (img.tagName === 'LINK') attrName = 'href'\n    else attrName = 'src'\n    let src = img.getAttribute(attrName)!\n    const match = src.match(/^(.*)\\?v=(\\d+)$/)\n    if (match) [, src, ovs] = match\n    if (src === oldsrc) {\n      if (ovs !== undefined) ov = parseInt(ovs, 10)\n      if (v !== ov) img[attrName] = v ? `${src}?v=${v}` : `${src}`\n    }\n  }\n})\n\nipcRenderer.on<'sync'>('sync', (_event, { line, flash }) => {\n  const root = document.querySelector('div.update-preview')\n  if (!root) return\n\n  let element = atomVars.sourceLineMap.get(line)\n\n  if (!element) {\n    for (let i = line - 1; i >= 0; i -= 1) {\n      element = atomVars.sourceLineMap.get(line)\n      if (element) break\n    }\n  }\n\n  if (!element) return\n\n  element.scrollIntoViewIfNeeded(true)\n\n  if (flash) {\n    element.classList.add('flash')\n    setTimeout(() => element!.classList.remove('flash'), 1000)\n  }\n})\n\nlet updatePromise: Promise<void> | undefined\nlet nextUpdateParams: ChannelMap['update-preview'] | undefined\nasync function doUpdate({\n  id,\n  html,\n  renderLaTeX,\n  map,\n  diffMethod,\n  scrollSyncParams,\n}: ChannelMap['update-preview']) {\n  // div.update-preview created after constructor st UpdatePreview cannot\n  // be instanced in the constructor\n  const preview = document.querySelector('div.update-preview')\n  if (!preview) return\n  const parser = new DOMParser()\n  const domDocument = parser.parseFromString(html, 'text/html')\n  const doc = document\n  if (doc && domDocument.head!.hasChildNodes()) {\n    let container = doc.head!.querySelector('original-elements')\n    if (!container) {\n      container = doc.createElement('original-elements')\n      doc.head!.insertBefore(container, doc.head!.firstElementChild)\n    }\n    container.innerHTML = ''\n    for (const headElement of Array.from(domDocument.head!.childNodes)) {\n      container.appendChild(headElement)\n    }\n  }\n  const visibleElements = scrollSyncParams\n    ? undefined\n    : Array.from(preview.children)\n        .map((x) => ({ el: x, r: x.getBoundingClientRect() }))\n        .filter(({ r }) => r.top <= window.innerHeight && r.bottom >= 0)\n  await update(preview, domDocument.body, {\n    renderLaTeX,\n    diffMethod,\n    mjController: await atomVars.mathJax,\n  })\n  if (visibleElements) {\n    const stillVisibleElements = visibleElements.filter(\n      ({ el }) => (el as HTMLElement).offsetParent,\n    )\n    const lastEl = stillVisibleElements[stillVisibleElements.length - 1]\n    if (lastEl) {\n      window.scrollBy({\n        top: lastEl.el.getBoundingClientRect().bottom - lastEl.r.bottom,\n      })\n    }\n  }\n  if (map) {\n    const slsm = new Map<number, Element>()\n    const rsm = new WeakMap<Element, number[]>()\n    for (const [lineS, path] of Object.entries(map)) {\n      const line = parseInt(lineS, 10)\n      const elem = util.resolveElement(preview, path)\n      if (elem) {\n        slsm.set(line, elem)\n        const rsmel = rsm.get(elem)\n        if (rsmel) rsmel.push(line)\n        else rsm.set(elem, [line])\n      }\n    }\n    atomVars.sourceLineMap = slsm\n    atomVars.revSourceMap = rsm\n  }\n  if (scrollSyncParams) scrollSync(scrollSyncParams)\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-request-reply'>(\n    'atom-markdown-preview-plus-ipc-request-reply',\n    handlerId,\n    {\n      id,\n      request: 'update-preview',\n      result: processHTMLString(preview),\n    },\n  )\n}\n\nfunction delayedUpdate(): Promise<void> | undefined {\n  let res\n  if (nextUpdateParams) res = doUpdate(nextUpdateParams).then(delayedUpdate)\n  nextUpdateParams = undefined\n  return res\n}\n\nipcRenderer.on<'update-preview'>('update-preview', (_event, params) => {\n  if (!updatePromise) {\n    updatePromise = doUpdate(params)\n      .then(delayedUpdate)\n      .catch(uncaughtError)\n      .then(() => {\n        updatePromise = undefined\n      })\n  } else {\n    nextUpdateParams = params\n  }\n})\n\nipcRenderer.on<'await-fully-ready'>('await-fully-ready', (_event, { id }) => {\n  function sendLoaded() {\n    requestAnimationFrame(function () {\n      ipcRenderer.send<'atom-markdown-preview-plus-ipc-request-reply'>(\n        'atom-markdown-preview-plus-ipc-request-reply',\n        handlerId,\n        {\n          id,\n          request: 'await-fully-ready',\n          result: void 0,\n        },\n      )\n    })\n  }\n  // tslint:disable-next-line: totality-check\n  if (document.readyState === 'complete') {\n    sendLoaded()\n    return\n  }\n  function loaded() {\n    sendLoaded()\n    window.removeEventListener('load', loaded)\n  }\n  window.addEventListener('load', loaded)\n})\n\nconst baseElement = document.createElement('base')\ndocument.head!.appendChild(baseElement)\n\nipcRenderer.on<'set-base-path'>('set-base-path', (_evt, { path }) => {\n  if (path) baseElement.href = path\n  else baseElement.href = ''\n})\n\nipcRenderer.on<'error'>('error', (_evt, { msg }) => {\n  const preview = document.querySelector('div.update-preview')\n  if (!preview) return\n  const errorDiv = document.createElement('div')\n  errorDiv.innerHTML = `<h2>Previewing Markdown Failed</h2><h3>${msg}</h3>`\n  if (preview.firstElementChild) {\n    preview.insertBefore(errorDiv, preview.firstElementChild)\n  } else {\n    preview.appendChild(errorDiv)\n  }\n})\n\ndocument.addEventListener('wheel', (event) => {\n  if (event.ctrlKey) {\n    if (event.deltaY > 0) {\n      ipcRenderer.send<'atom-markdown-preview-plus-ipc-zoom-in'>(\n        'atom-markdown-preview-plus-ipc-zoom-in',\n        handlerId,\n      )\n    } else if (event.deltaY < 0) {\n      ipcRenderer.send<'atom-markdown-preview-plus-ipc-zoom-out'>(\n        'atom-markdown-preview-plus-ipc-zoom-out',\n        handlerId,\n      )\n    }\n    event.preventDefault()\n    event.stopPropagation()\n  }\n})\n\ndocument.addEventListener('scroll', (_event) => {\n  const el = document.documentElement!\n  const height = el.clientHeight\n  const visible = Array.from(atomVars.sourceLineMap.entries())\n    .filter(([_line, elem]) => {\n      const { top, bottom } = elem.getBoundingClientRect()\n      return top > 0 && bottom < height\n    })\n    .map(([line, _elem]) => line)\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-did-scroll-preview'>(\n    'atom-markdown-preview-plus-ipc-did-scroll-preview',\n    handlerId,\n    {\n      max: Math.max(...visible),\n      min: Math.min(...visible),\n    },\n  )\n})\n\nfunction keyEventHandler(type: 'keydown' | 'keyup', e: KeyboardEvent) {\n  if (\n    nativePageScrollKeys &&\n    !e.altKey &&\n    !e.ctrlKey &&\n    !e.shiftKey &&\n    !e.metaKey &&\n    e.code.match(/^(Arrow.*|Page.*|Space|Home|End)$/)\n  ) {\n    return\n  }\n  const data = {\n    type: type,\n    altKey: e.altKey,\n    ctrlKey: e.ctrlKey,\n    bubbles: e.bubbles,\n    cancelable: e.cancelable,\n    code: e.code,\n    composed: e.composed,\n    detail: e.detail,\n    isComposing: e.isComposing,\n    key: e.key,\n    location: e.location,\n    metaKey: e.metaKey,\n    repeat: e.repeat,\n    shiftKey: e.shiftKey,\n  } as const\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-key'>(\n    'atom-markdown-preview-plus-ipc-key',\n    handlerId,\n    data,\n  )\n  e.preventDefault()\n}\n\ndocument.addEventListener('keydown', keyEventHandler.bind(this, 'keydown'))\ndocument.addEventListener('keyup', keyEventHandler.bind(this, 'keyup'))\n\nlet lastContextMenuTarget: HTMLElement\ndocument.addEventListener('contextmenu', (e) => {\n  lastContextMenuTarget = e.target as HTMLElement\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-show-context-menu'>(\n    'atom-markdown-preview-plus-ipc-show-context-menu',\n    handlerId,\n  )\n})\n\nipcRenderer.on<'sync-source'>('sync-source', (_, { id }) => {\n  let element = lastContextMenuTarget\n  const rsm = atomVars.revSourceMap\n  let lines = rsm.get(element)\n\n  while (!lines && element.parentElement) {\n    element = element.parentElement\n    lines = rsm.get(element)\n  }\n  if (!lines) return\n\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-request-reply'>(\n    'atom-markdown-preview-plus-ipc-request-reply',\n    handlerId,\n    {\n      id,\n      request: 'sync-source',\n      result: Math.min(...lines),\n    },\n  )\n})\n\nipcRenderer.on<'reload'>('reload', (_, { id }) => {\n  window.onbeforeunload = null\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-request-reply'>(\n    'atom-markdown-preview-plus-ipc-request-reply',\n    handlerId,\n    {\n      id,\n      request: 'reload',\n      result: undefined,\n    },\n  )\n})\n\nwindow.onbeforeunload = function () {\n  return false\n}\n\nipcRenderer.on<'get-tex-config'>('get-tex-config', async (_, { id }) => {\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-request-reply'>(\n    'atom-markdown-preview-plus-ipc-request-reply',\n    handlerId,\n    {\n      id,\n      request: 'get-tex-config',\n      result: (await atomVars.mathJax).jaxTeXConfig(),\n    },\n  )\n})\n\nipcRenderer.on<'get-selection'>('get-selection', async (_, { id }) => {\n  const selection = window.getSelection()\n  const selectedText = selection && selection.toString()\n  const selectedNode = selection && selection.anchorNode\n\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-request-reply'>(\n    'atom-markdown-preview-plus-ipc-request-reply',\n    handlerId,\n    {\n      id,\n      request: 'get-selection',\n      result: selectedText && selectedNode ? selectedText : undefined,\n    },\n  )\n})\n\ndocument.addEventListener('click', (event) => {\n  if (!event.target) return\n  const el = event.target as HTMLElement\n  if (el.tagName === 'A') {\n    const href = el.getAttribute('href')\n    if (href && href.startsWith('#')) {\n      event.preventDefault()\n      const anchor = document.getElementById(decodeURIComponent(href).slice(1))\n      if (anchor) anchor.scrollIntoView()\n    }\n  }\n})\n"],"names":["$parcel$global","globalThis","self","window","global","async","oldDom","newDom","opts","idMap","WeakMap","diffMethod","$5e2809a972ae7bfa373943673e1ca445$var$time","idx","matchEls","newRoot","oldRoot","newEl","firstChild","oldEl","newCount","childNodes","length","oldCount","$5e2809a972ae7bfa373943673e1ca445$var$isEqual","nodeType","Node","ELEMENT_NODE","sidx","toString","set","nextSibling","$5e2809a972ae7bfa373943673e1ca445$var$runHeuristic","a","Array","from","$5e2809a972ae7bfa373943673e1ca445$var$allChildren","b","ncomp","$18d51fb2741d90bc9911906e0bb035ac$exports","diff","pairs","x","y","console","log","childrenOnly","onBeforeElUpdated","fromEl","toEl","isEqualNode","tcs","$5e2809a972ae7bfa373943673e1ca445$var$getMathContents","textContent","getNodeKey","node","get","e","error","innerHTML","renderLaTeX","mjController","queueTypeset","$bf985ba33342093ded2eaf89156dc30e$var$range","$bf985ba33342093ded2eaf89156dc30e$var$doc","document","undefined","$bf985ba33342093ded2eaf89156dc30e$var$HAS_TEMPLATE_SUPPORT","createElement","$bf985ba33342093ded2eaf89156dc30e$var$HAS_RANGE_SUPPORT","createRange","$bf985ba33342093ded2eaf89156dc30e$var$toElement","str","trim","template","content","$bf985ba33342093ded2eaf89156dc30e$var$createFragmentFromTemplate","selectNode","body","createContextualFragment","$bf985ba33342093ded2eaf89156dc30e$var$createFragmentFromRange","fragment","$bf985ba33342093ded2eaf89156dc30e$var$createFragmentFromWrap","$bf985ba33342093ded2eaf89156dc30e$var$compareNodeNames","fromCodeStart","toCodeStart","fromNodeName","nodeName","toNodeName","charCodeAt","toUpperCase","$bf985ba33342093ded2eaf89156dc30e$var$syncBooleanAttrProp","name","setAttribute","removeAttribute","$bf985ba33342093ded2eaf89156dc30e$var$specialElHandlers","OPTION","parentNode","parentName","hasAttribute","selected","selectedIndex","INPUT","value","TEXTAREA","newValue","oldValue","nodeValue","placeholder","SELECT","optgroup","i","curChild","$bf985ba33342093ded2eaf89156dc30e$var$noop","$bf985ba33342093ded2eaf89156dc30e$var$defaultGetNodeKey","getAttribute","id","morphAttrs","n","v","$bf985ba33342093ded2eaf89156dc30e$export$default","fromNode","toNode","attr","attrName","attrNamespaceURI","attrValue","toNodeAttrs","attributes","namespaceURI","localName","getAttributeNS","prefix","setAttributeNS","fromNodeAttrs","d","hasAttributeNS","removeAttributeNS","options","toNodeHtml","onBeforeNodeAdded","onNodeAdded","onElUpdated","onBeforeNodeDiscarded","onNodeDiscarded","onBeforeElChildrenUpdated","fromNodesLookup","Object","create","keyedRemovalList","addKeyedRemoval","key","push","walkDiscardedChildNodes","skipKeyedNodes","removeNode","removeChild","handleNodeAdded","el","unmatchedFromEl","replaceChild","morphEl","toElKey","curToNodeKey","curFromNodeKey","fromNextSibling","toNextSibling","matchingFromEl","curToNodeChild","curFromNodeChild","outer","isSameNode","curFromNodeType","isCompatible","insertBefore","appendChild","onBeforeNodeAddedResult","actualize","ownerDocument","cleanupFromEl","specialElHandler","morphChildren","indexTree","morphedNode","morphedNodeType","toNodeType","nextChild","$bf985ba33342093ded2eaf89156dc30e$var$moveChildren","createElementNS","$bf985ba33342093ded2eaf89156dc30e$var$COMMENT_NODE","len","elToRemove","defineProperty","enumerable","left","right","compare","match","slices","go","f","j","N","M","L","Z","Math","min","w","g","p","fill","h","r","c","o","m","k","max","s","t","z","D","u","slice","$18d51fb2741d90bc9911906e0bb035ac$var$slicesToItems","promise","catch","filePath","isFile","root","pathToToken","element","token","candidateElement","querySelectorAll","tag","item","index","ita","Symbol","iterator","itb","next","done","$5e2809a972ae7bfa373943673e1ca445$var$isElement","tagName","classList","contains","ascr","querySelector","bscr","type","$5e2809a972ae7bfa373943673e1ca445$var$isEqualMath","ac","bc","DOCUMENT_TYPE_NODE","publicId","systemId","$5e2809a972ae7bfa373943673e1ca445$var$checkDocumentType","every","getNamedItemNS","$5e2809a972ae7bfa373943673e1ca445$var$checkElement","ATTRIBUTE_NODE","$5e2809a972ae7bfa373943673e1ca445$var$checkAttr","PROCESSING_INSTRUCTION_NODE","target","data","$5e2809a972ae7bfa373943673e1ca445$var$checkProcInstr","TEXT_NODE","COMMENT_NODE","$5e2809a972ae7bfa373943673e1ca445$var$checkData","children","cb","start","performance","now","res","msvgh","getElementById","svgGlyphs","parentElement","outerHTML","$18ff8c2ffe0e176653c7b6ca5d260e03$var$MathJaxController","constructor","userMacros","mathJaxConfig","this","readyPromise","attachMathJax","controller","dispose","script","head","mjSrc","remove","jaxTeXConfig","extensions","texExtensions","Macros","equationNumbers","numberEquations","autoNumber","useLabelIds","domElement","allMath","filter","jax","MathJax","Hub","getJaxFor","inputID","needsUpdate","Promise","resolve","InputJax","TeX","Queue","temps","spans","setupTemps","cleanupTemps","span","temp","style","visibility","position","width","display","scriptElements","par","disp","previousElementSibling","cloneNode","add","includes","getComputedStyle","scriptSrc","src","addEventListener","$18ff8c2ffe0e176653c7b6ca5d260e03$var$injectScript","Config","latexRenderer","HTML-CSS","availableFonts","webFont","imageFont","undefinedFamily","mtextFontInherit","messageStyle","showMathMenu","skipStartupTypeset","Configured","require","$836392e7fce7018574f9c63f48631ab1$var$handlerId","$836392e7fce7018574f9c63f48631ab1$var$nativePageScrollKeys","$836392e7fce7018574f9c63f48631ab1$var$uncaughtError","err","send","message","stack","evt","reason","$836392e7fce7018574f9c63f48631ab1$var$atomVars","mathJax","resFn","$836392e7fce7018574f9c63f48631ab1$var$mkResPromise","sourceLineMap","Map","revSourceMap","$836392e7fce7018574f9c63f48631ab1$var$scrollSync","firstLine","lastLine","scroll","top","slm","lines","keys","sort","lowix","findIndex","highix","low","high","norm","meanScroll","entries","line","weight","getBoundingClientRect","documentElement","scrollTop","clientHeight","$836392e7fce7018574f9c63f48631ab1$var$updatePromise","$836392e7fce7018574f9c63f48631ab1$var$nextUpdateParams","$836392e7fce7018574f9c63f48631ab1$var$doUpdate","html","map","scrollSyncParams","preview","domDocument","parser","DOMParser","parseFromString","doc","hasChildNodes","container","firstElementChild","headElement","visibleElements","innerHeight","bottom","$5e2809a972ae7bfa373943673e1ca445$exports","update","stillVisibleElements","offsetParent","lastEl","scrollBy","slsm","rsm","lineS","path","parseInt","elem","$836392e7fce7018574f9c63f48631ab1$var$util","resolveElement","rsmel","request","result","$836392e7fce7018574f9c63f48631ab1$var$delayedUpdate","then","on","_evt","params","dataset","markdownPreviewPlusContext","context","setProperty","pdfExportOptions","val","_event","styles","styleElem","join","oldsrc","imgs","img","ovs","ov","flash","scrollIntoViewIfNeeded","setTimeout","sendLoaded","requestAnimationFrame","readyState","loaded","removeEventListener","$836392e7fce7018574f9c63f48631ab1$var$baseElement","$836392e7fce7018574f9c63f48631ab1$var$keyEventHandler","altKey","ctrlKey","shiftKey","metaKey","code","bubbles","cancelable","composed","detail","isComposing","location","repeat","preventDefault","$836392e7fce7018574f9c63f48631ab1$var$lastContextMenuTarget","href","msg","errorDiv","event","deltaY","stopPropagation","height","visible","_line","_elem","bind","_","onbeforeunload","selection","getSelection","selectedText","selectedNode","anchorNode","startsWith","anchor","decodeURIComponent","scrollIntoView"],"version":3,"file":"main.js.map"}