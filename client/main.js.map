{"mappings":"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","sources":["./home/livid/github/other/markdown-preview-plus/node_modules/@parcel/scope-hoisting/lib/helpers.js","./src-client/main.ts","./src-client/update-preview.ts","./node_modules/morphdom/dist/morphdom-esm.js","./src-client/diff.ts","./src-client/util.ts","./src-client/mathjax-helper.ts","./src/util-common.ts"],"sourcesContent":[null,"import { ipcRenderer } from 'electron'\nimport { update } from './update-preview'\nimport { MathJaxController, processHTMLString } from './mathjax-helper'\nimport * as util from './util'\nimport { getMedia } from '../src/util-common'\nimport { ChannelMap } from './ipc'\n\nlet handlerId: number\nlet nativePageScrollKeys = false\n\nfunction uncaughtError(err: Error) {\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-uncaught-error'>(\n    'atom-markdown-preview-plus-ipc-uncaught-error',\n    handlerId,\n    {\n      message: err.message,\n      name: err.name,\n      stack: err.stack,\n    },\n  )\n}\n\nwindow.addEventListener('error', (e) => {\n  uncaughtError(e.error as Error)\n})\n\nwindow.addEventListener('unhandledrejection', (evt) => {\n  uncaughtError((evt as any).reason as Error)\n})\n\nfunction mkResPromise<T>() {\n  let resFn: (value?: T | PromiseLike<T> | undefined) => void\n  const p = new Promise<T>((resolve) => (resFn = resolve)) as Promise<T> & {\n    resolve: typeof resFn\n  }\n  p.resolve = resFn!\n  return p\n}\n\nconst atomVars = {\n  mathJax: mkResPromise<MathJaxController>(),\n  sourceLineMap: new Map<number, Element>(),\n  revSourceMap: new WeakMap<Element, number[]>(),\n}\n\nipcRenderer.on<'set-id'>('set-id', (_evt, id) => {\n  handlerId = id\n})\n\nipcRenderer.on<'init'>('init', (_evt, params) => {\n  atomVars.mathJax.resolve(\n    MathJaxController.create(params.userMacros, params.mathJaxConfig),\n  )\n  document.documentElement!.dataset.markdownPreviewPlusContext = params.context\n  // tslint:disable-next-line:totality-check\n  if (params.context === 'pdf-export') {\n    document.documentElement!.style.setProperty(\n      'width',\n      `${params.pdfExportOptions.width}mm`,\n      'important',\n    )\n  }\n})\n\nipcRenderer.on<'set-native-keys'>('set-native-keys', (_evt, val) => {\n  nativePageScrollKeys = val\n})\n\nfunction scrollSync({ firstLine, lastLine }: ChannelMap['scroll-sync']) {\n  if (firstLine === 0) {\n    window.scroll({ top: 0 })\n    return\n  }\n  const slm = atomVars.sourceLineMap\n  const lines = Array.from(slm.keys()).sort((a, b) => a - b)\n  let lowix = lines.findIndex((x) => x >= firstLine)\n  if (lowix > 0) lowix--\n  let highix = lines.findIndex((x) => x >= lastLine)\n  if (highix === -1) highix = lines.length - 1\n  else if (highix < lines.length - 1) highix++\n  const low = lines[lowix]\n  const high = lines[highix]\n  let norm = 0\n  let meanScroll = 0\n  const entries = Array.from(slm.entries()).slice(lowix, highix + 1)\n  for (const [line, item] of entries) {\n    const weight = line <= (high + low) / 2 ? line - low + 1 : high - line + 1\n    norm += weight\n    meanScroll += item.getBoundingClientRect().top * weight\n  }\n  if (norm === 0) return\n  const offset = document.documentElement!.scrollTop\n  const clientHeight = document.documentElement!.clientHeight\n  const top = offset - clientHeight / 2 + meanScroll / norm\n  window.scroll({ top })\n}\n\nipcRenderer.on<'scroll-sync'>('scroll-sync', (_evt, params) => {\n  scrollSync(params)\n})\n\nipcRenderer.on<'style'>('style', (_event, { styles }) => {\n  let styleElem = document.head!.querySelector('style#atom-styles')\n  if (!styleElem) {\n    styleElem = document.createElement('style')\n    styleElem.id = 'atom-styles'\n    document.head!.appendChild(styleElem)\n  }\n  styleElem.innerHTML = styles.join('\\n')\n})\n\nipcRenderer.on<'update-images'>('update-images', (_event, { oldsrc, v }) => {\n  const imgs = getMedia(document)\n  for (const img of Array.from(imgs)) {\n    let ovs: string | undefined\n    let ov: number | undefined\n    let attrName: 'href' | 'src'\n    if (img.tagName === 'LINK') attrName = 'href'\n    else attrName = 'src'\n    let src = img.getAttribute(attrName)!\n    const match = src.match(/^(.*)\\?v=(\\d+)$/)\n    if (match) [, src, ovs] = match\n    if (src === oldsrc) {\n      if (ovs !== undefined) ov = parseInt(ovs, 10)\n      if (v !== ov) img[attrName] = v ? `${src}?v=${v}` : `${src}`\n    }\n  }\n})\n\nipcRenderer.on<'sync'>('sync', (_event, { line, flash }) => {\n  const root = document.querySelector('div.update-preview')\n  if (!root) return\n\n  let element = atomVars.sourceLineMap.get(line)\n\n  if (!element) {\n    for (let i = line - 1; i >= 0; i -= 1) {\n      element = atomVars.sourceLineMap.get(line)\n      if (element) break\n    }\n  }\n\n  if (!element) return\n\n  element.scrollIntoViewIfNeeded(true)\n\n  if (flash) {\n    element.classList.add('flash')\n    setTimeout(() => element!.classList.remove('flash'), 1000)\n  }\n})\n\nlet updatePromise: Promise<void> | undefined\nlet nextUpdateParams: ChannelMap['update-preview'] | undefined\nasync function doUpdate({\n  id,\n  html,\n  renderLaTeX,\n  map,\n  diffMethod,\n  scrollSyncParams,\n}: ChannelMap['update-preview']) {\n  // div.update-preview created after constructor st UpdatePreview cannot\n  // be instanced in the constructor\n  const preview = document.querySelector('div.update-preview')\n  if (!preview) return\n  const parser = new DOMParser()\n  const domDocument = parser.parseFromString(html, 'text/html')\n  const doc = document\n  if (doc && domDocument.head!.hasChildNodes) {\n    let container = doc.head!.querySelector('original-elements')\n    if (!container) {\n      container = doc.createElement('original-elements')\n      doc.head!.insertBefore(container, doc.head!.firstElementChild)\n    }\n    container.innerHTML = ''\n    for (const headElement of Array.from(domDocument.head!.childNodes)) {\n      container.appendChild(headElement)\n    }\n  }\n  const visibleElements = scrollSyncParams\n    ? undefined\n    : Array.from(preview.children)\n        .map((x) => ({ el: x, r: x.getBoundingClientRect() }))\n        .filter(({ r }) => r.top <= window.innerHeight && r.bottom >= 0)\n  await update(preview, domDocument.body, {\n    renderLaTeX,\n    diffMethod,\n    mjController: await atomVars.mathJax,\n  })\n  if (visibleElements) {\n    const stillVisibleElements = visibleElements.filter(\n      ({ el }) => (el as HTMLElement).offsetParent,\n    )\n    const lastEl = stillVisibleElements[stillVisibleElements.length - 1]\n    if (lastEl) {\n      window.scrollBy({\n        top: lastEl.el.getBoundingClientRect().bottom - lastEl.r.bottom,\n      })\n    }\n  }\n  if (map) {\n    const slsm = new Map<number, Element>()\n    const rsm = new WeakMap<Element, number[]>()\n    for (const [lineS, path] of Object.entries(map)) {\n      const line = parseInt(lineS, 10)\n      const elem = util.resolveElement(preview, path)\n      if (elem) {\n        slsm.set(line, elem)\n        const rsmel = rsm.get(elem)\n        if (rsmel) rsmel.push(line)\n        else rsm.set(elem, [line])\n      }\n    }\n    atomVars.sourceLineMap = slsm\n    atomVars.revSourceMap = rsm\n  }\n  if (scrollSyncParams) scrollSync(scrollSyncParams)\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-request-reply'>(\n    'atom-markdown-preview-plus-ipc-request-reply',\n    handlerId,\n    {\n      id,\n      request: 'update-preview',\n      result: processHTMLString(preview),\n    },\n  )\n}\n\nfunction delayedUpdate(): Promise<void> | undefined {\n  let res\n  if (nextUpdateParams) res = doUpdate(nextUpdateParams).then(delayedUpdate)\n  nextUpdateParams = undefined\n  return res\n}\n\nipcRenderer.on<'update-preview'>('update-preview', (_event, params) => {\n  if (!updatePromise) {\n    updatePromise = doUpdate(params)\n      .then(delayedUpdate)\n      .catch(uncaughtError)\n      .then(() => {\n        updatePromise = undefined\n      })\n  } else {\n    nextUpdateParams = params\n  }\n})\n\nipcRenderer.on<'await-fully-ready'>(\n  'await-fully-ready',\n  async (_event, { id }) => {\n    // tslint:disable-next-line: totality-check\n    if (document.readyState === 'complete') {\n      ipcRenderer.send<'atom-markdown-preview-plus-ipc-request-reply'>(\n        'atom-markdown-preview-plus-ipc-request-reply',\n        handlerId,\n        {\n          id,\n          request: 'await-fully-ready',\n          result: void 0,\n        },\n      )\n      return\n    }\n    function loaded() {\n      ipcRenderer.send<'atom-markdown-preview-plus-ipc-request-reply'>(\n        'atom-markdown-preview-plus-ipc-request-reply',\n        handlerId,\n        {\n          id,\n          request: 'await-fully-ready',\n          result: void 0,\n        },\n      )\n      document.removeEventListener('load', loaded)\n    }\n    document.addEventListener('load', loaded)\n  },\n)\n\nconst baseElement = document.createElement('base')\ndocument.head!.appendChild(baseElement)\n\nipcRenderer.on<'set-base-path'>('set-base-path', (_evt, { path }) => {\n  if (path) baseElement.href = path\n  else baseElement.href = ''\n})\n\nipcRenderer.on<'error'>('error', (_evt, { msg }) => {\n  const preview = document.querySelector('div.update-preview')\n  if (!preview) return\n  const errorDiv = document.createElement('div')\n  errorDiv.innerHTML = `<h2>Previewing Markdown Failed</h2><h3>${msg}</h3>`\n  if (preview.firstElementChild) {\n    preview.insertBefore(errorDiv, preview.firstElementChild)\n  } else {\n    preview.appendChild(errorDiv)\n  }\n})\n\ndocument.addEventListener('wheel', (event) => {\n  if (event.ctrlKey) {\n    if (event.deltaY > 0) {\n      ipcRenderer.send<'atom-markdown-preview-plus-ipc-zoom-in'>(\n        'atom-markdown-preview-plus-ipc-zoom-in',\n        handlerId,\n      )\n    } else if (event.deltaY < 0) {\n      ipcRenderer.send<'atom-markdown-preview-plus-ipc-zoom-out'>(\n        'atom-markdown-preview-plus-ipc-zoom-out',\n        handlerId,\n      )\n    }\n    event.preventDefault()\n    event.stopPropagation()\n  }\n})\n\ndocument.addEventListener('scroll', (_event) => {\n  const el = document.documentElement!\n  const height = el.clientHeight\n  const visible = Array.from(atomVars.sourceLineMap.entries())\n    .filter(([_line, elem]) => {\n      const { top, bottom } = elem.getBoundingClientRect()\n      return top > 0 && bottom < height\n    })\n    .map(([line, _elem]) => line)\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-did-scroll-preview'>(\n    'atom-markdown-preview-plus-ipc-did-scroll-preview',\n    handlerId,\n    {\n      max: Math.max(...visible),\n      min: Math.min(...visible),\n    },\n  )\n})\n\nfunction keyEventHandler(type: 'keydown' | 'keyup', e: KeyboardEvent) {\n  if (\n    nativePageScrollKeys &&\n    !e.altKey &&\n    !e.ctrlKey &&\n    !e.shiftKey &&\n    !e.metaKey &&\n    e.code.match(/^(Arrow.*|Page.*|Space|Home|End)$/)\n  ) {\n    return\n  }\n  const data = {\n    type: type,\n    altKey: e.altKey,\n    ctrlKey: e.ctrlKey,\n    bubbles: e.bubbles,\n    cancelable: e.cancelable,\n    code: e.code,\n    composed: e.composed,\n    detail: e.detail,\n    isComposing: e.isComposing,\n    key: e.key,\n    location: e.location,\n    metaKey: e.metaKey,\n    repeat: e.repeat,\n    shiftKey: e.shiftKey,\n  } as const\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-key'>(\n    'atom-markdown-preview-plus-ipc-key',\n    handlerId,\n    data,\n  )\n  e.preventDefault()\n}\n\ndocument.addEventListener('keydown', keyEventHandler.bind(this, 'keydown'))\ndocument.addEventListener('keyup', keyEventHandler.bind(this, 'keyup'))\n\nlet lastContextMenuTarget: HTMLElement\ndocument.addEventListener('contextmenu', (e) => {\n  lastContextMenuTarget = e.target as HTMLElement\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-show-context-menu'>(\n    'atom-markdown-preview-plus-ipc-show-context-menu',\n    handlerId,\n  )\n})\n\nipcRenderer.on<'sync-source'>('sync-source', (_, { id }) => {\n  let element = lastContextMenuTarget\n  const rsm = atomVars.revSourceMap\n  let lines = rsm.get(element)\n\n  while (!lines && element.parentElement) {\n    element = element.parentElement\n    lines = rsm.get(element)\n  }\n  if (!lines) return\n\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-request-reply'>(\n    'atom-markdown-preview-plus-ipc-request-reply',\n    handlerId,\n    {\n      id,\n      request: 'sync-source',\n      result: Math.min(...lines),\n    },\n  )\n})\n\nipcRenderer.on<'reload'>('reload', (_, { id }) => {\n  window.onbeforeunload = null\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-request-reply'>(\n    'atom-markdown-preview-plus-ipc-request-reply',\n    handlerId,\n    {\n      id,\n      request: 'reload',\n      result: undefined,\n    },\n  )\n})\n\nwindow.onbeforeunload = function () {\n  return false\n}\n\nipcRenderer.on<'get-tex-config'>('get-tex-config', async (_, { id }) => {\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-request-reply'>(\n    'atom-markdown-preview-plus-ipc-request-reply',\n    handlerId,\n    {\n      id,\n      request: 'get-tex-config',\n      result: (await atomVars.mathJax).jaxTeXConfig(),\n    },\n  )\n})\n\nipcRenderer.on<'get-selection'>('get-selection', async (_, { id }) => {\n  const selection = window.getSelection()\n  const selectedText = selection && selection.toString()\n  const selectedNode = selection && selection.anchorNode\n\n  ipcRenderer.send<'atom-markdown-preview-plus-ipc-request-reply'>(\n    'atom-markdown-preview-plus-ipc-request-reply',\n    handlerId,\n    {\n      id,\n      request: 'get-selection',\n      result: selectedText && selectedNode ? selectedText : undefined,\n    },\n  )\n})\n\ndocument.addEventListener('click', (event) => {\n  if (!event.target) return\n  const el = event.target as HTMLElement\n  if (el.tagName === 'A') {\n    const href = el.getAttribute('href')\n    if (href && href.startsWith('#')) {\n      event.preventDefault()\n      const anchor = document.getElementById(decodeURIComponent(href).slice(1))\n      if (anchor) anchor.scrollIntoView()\n    }\n  }\n})\n","import morph from 'morphdom'\nimport { MathJaxController } from './mathjax-helper'\nimport { diff } from './diff'\nimport { TDiffMethod } from './ipc'\n\nfunction isEqualMath(a: Node, b: Node) {\n  const tcs = getMathContents(a, b)\n  return tcs && tcs[0].textContent === tcs[1].textContent\n}\n\nfunction getMathContents(a: Node, b: Node) {\n  if (!isElement(a) || !isElement(b)) return false\n  if (\n    a.tagName !== 'SPAN' ||\n    b.tagName !== 'SPAN' ||\n    !a.classList.contains('math') ||\n    !b.classList.contains('math')\n  ) {\n    return false\n  }\n  const ascr = a.querySelector<HTMLScriptElement>(':scope > script')\n  if (!ascr) return false\n  const bscr = b.querySelector<HTMLScriptElement>(':scope > script')\n  if (!bscr) return false\n  if (ascr.type !== bscr.type) return false\n  return [ascr, bscr] as const\n}\n\nfunction isElement(a: Node): a is Element {\n  return a.nodeType === Node.ELEMENT_NODE\n}\n\nfunction checkDocumentType(a: DocumentType, b: DocumentType) {\n  return (\n    a.name === b.name && a.publicId === b.publicId && a.systemId === b.systemId\n  )\n}\n\nfunction checkElement(a: Element, b: Element) {\n  if (a.attributes.length !== b.attributes.length) return false\n  return Array.from(a.attributes).every((x) =>\n    x.isEqualNode(b.attributes.getNamedItemNS(x.namespaceURI, x.localName)),\n  )\n}\n\nfunction checkAttr(a: Attr, b: Attr) {\n  return (\n    a.namespaceURI === b.namespaceURI &&\n    a.localName === b.localName &&\n    a.value === b.value\n  )\n}\n\nfunction checkProcInstr(a: ProcessingInstruction, b: ProcessingInstruction) {\n  return a.target === b.target && a.data === b.data\n}\n\nfunction checkData(a: { data: string }, b: { data: string }) {\n  return a.data === b.data\n}\n\n// based on https://dom.spec.whatwg.org/#concept-node-equals\nfunction isEqual(a: Node, b: Node): boolean {\n  // early bailouts\n  if (a.isEqualNode(b)) return true\n  if (isEqualMath(a, b)) return true\n\n  // node checks\n  if (a.nodeType !== b.nodeType) return false\n  if (a.childNodes.length !== b.childNodes.length) return false\n\n  // recursively check children\n  let ac = a.firstChild\n  let bc = b.firstChild\n  while (ac && bc) {\n    if (!isEqual(ac, bc)) return false\n    ac = ac.nextSibling\n    bc = bc.nextSibling\n  }\n\n  switch (a.nodeType) {\n    case Node.DOCUMENT_TYPE_NODE:\n      return checkDocumentType(a as DocumentType, b as DocumentType)\n    case Node.ELEMENT_NODE:\n      return checkElement(a as Element, b as Element)\n    case Node.ATTRIBUTE_NODE:\n      return checkAttr(a as Attr, b as Attr)\n    case Node.PROCESSING_INSTRUCTION_NODE:\n      return checkProcInstr(\n        a as ProcessingInstruction,\n        b as ProcessingInstruction,\n      )\n    case Node.TEXT_NODE:\n    case Node.COMMENT_NODE:\n      return checkData(a as Text | Comment, b as Text | Comment)\n    default:\n      return true\n  }\n}\n\nfunction* allChildren(node: Element): IterableIterator<Element> {\n  for (const c of node.children) {\n    if (c.tagName === 'SPAN' && c.classList.contains('MathJax')) continue\n    if (c.tagName === 'SPAN' && c.classList.contains('MathJax_SVG')) continue\n    if (c.tagName === 'SCRIPT') continue\n    if (c.tagName === 'DIV' && c.classList.contains('MathJax_Display')) continue\n    if (c.tagName === 'DIV' && c.classList.contains('MathJax_SVG_Display')) {\n      continue\n    }\n    yield c\n    if (c.tagName === 'PRE' && c.classList.contains('editor-colors')) continue\n    yield* allChildren(c)\n  }\n}\n\nfunction runHeuristic(\n  idMap: WeakMap<Node, string>,\n  newDom: Element,\n  oldDom: Element,\n): void {\n  let idx = 0\n  // pre-match nodes in both trees\n  function matchEls(newRoot: Node, oldRoot: Node) {\n    let newEl = newRoot.firstChild\n    let oldEl = oldRoot.firstChild\n    const newCount = newRoot.childNodes.length\n    const oldCount = oldRoot.childNodes.length\n    if (newCount > oldCount) {\n      // checking for insertions\n      while (oldEl && newEl) {\n        if (isEqual(newEl, oldEl)) {\n          if (newEl.nodeType === Node.ELEMENT_NODE) {\n            const sidx = idx.toString(36)\n            idMap.set(oldEl, sidx)\n            idMap.set(newEl, sidx)\n            idx++\n          }\n          matchEls(newEl, oldEl)\n          oldEl = oldEl.nextSibling\n        }\n        newEl = newEl.nextSibling\n      }\n    } else if (newCount < oldCount) {\n      // checking for deletions\n      while (oldEl && newEl) {\n        if (isEqual(newEl, oldEl)) {\n          if (newEl.nodeType === Node.ELEMENT_NODE) {\n            const sidx = idx.toString(36)\n            idMap.set(oldEl, sidx)\n            idMap.set(newEl, sidx)\n            idx++\n          }\n          matchEls(newEl, oldEl)\n          newEl = newEl.nextSibling\n        }\n        oldEl = oldEl.nextSibling\n      }\n    }\n  }\n  matchEls(newDom, oldDom)\n}\n\nfunction time<T>(cb: () => T): T {\n  const start = performance.now()\n  const res = cb()\n  console.log(cb.toString(), performance.now() - start, 'ms')\n  return res\n}\nexport async function update(\n  oldDom: Element,\n  newDom: Element,\n  opts: {\n    mjController: MathJaxController\n    renderLaTeX: boolean\n    diffMethod: TDiffMethod\n  },\n): Promise<void> {\n  const idMap = new WeakMap<Node, string>()\n  switch (opts.diffMethod) {\n    case 'heuristic': {\n      time(() => runHeuristic(idMap, newDom, oldDom))\n      break\n    }\n    case 'myers': {\n      const a = time(() => Array.from(allChildren(oldDom)))\n      const b = time(() => Array.from(allChildren(newDom)))\n      let ncomp = 0\n      let idx = 0\n      time(() =>\n        diff(\n          a,\n          b,\n          (a, b) => {\n            ncomp++\n            return isEqual(a, b)\n          },\n          (pairs) => {\n            for (const [x, y] of pairs) {\n              const sidx = idx.toString(36)\n              idMap.set(x, sidx)\n              idMap.set(y, sidx)\n              idx++\n            }\n          },\n        ),\n      )\n      console.log('a:', a.length, 'b:', b.length, 'comp:', ncomp)\n      break\n    }\n    case 'none':\n      break\n  }\n\n  try {\n    morph(oldDom, newDom, {\n      childrenOnly: true,\n      onBeforeElUpdated(fromEl, toEl) {\n        if (fromEl.isEqualNode(toEl)) return false\n        const tcs = getMathContents(fromEl, toEl)\n        if (tcs) {\n          if (tcs[0].textContent !== tcs[1].textContent) {\n            tcs[0].textContent = tcs[1].textContent\n          }\n          return false\n        }\n        return true\n      },\n      getNodeKey(node: Element) {\n        return idMap.get(node) || ''\n      },\n    })\n  } catch (e) {\n    console.error(e)\n    oldDom.innerHTML = newDom.innerHTML\n  }\n\n  if (opts.renderLaTeX) await opts.mjController.queueTypeset(oldDom)\n}\n","var DOCUMENT_FRAGMENT_NODE = 11;\n\nfunction morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // document-fragments dont have attributes so lets not do anything\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    // update attributes on original DOM element\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n        attr = toNodeAttrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                if (attr.prefix === 'xmlns'){\n                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix\n                }\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n        attr = fromNodeAttrs[d];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n\n            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n            }\n        } else {\n            if (!toNode.hasAttribute(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();\n\nfunction createFragmentFromTemplate(str) {\n    var template = doc.createElement('template');\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n}\n\nfunction createFragmentFromRange(str) {\n    if (!range) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n}\n\nfunction createFragmentFromWrap(str) {\n    var fragment = doc.createElement('body');\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n}\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n    str = str.trim();\n    if (HAS_TEMPLATE_SUPPORT) {\n      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which\n      // createContextualFragment doesn't support\n      // <template> support not available in IE\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    // If the target element is a virtual DOM node or SVG node then we may\n    // need to normalize the tag name before comparing. Normal HTML elements that are\n    // in the \"http://www.w3.org/1999/xhtml\"\n    // are converted to upper case\n    if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower\n        return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower\n        return toNodeName === fromNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE$1 = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n  if (node) {\n      return (node.getAttribute && node.getAttribute('id')) || node.id;\n  }\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = Object.create(null);\n        var keyedRemovalList = [];\n\n        function addKeyedRemoval(key) {\n            keyedRemovalList.push(key);\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    // if we find a duplicate #id node in cache, replace `el` with cache value\n                    // and morph it to the child node.\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphEl(unmatchedFromEl, curChild);\n                    } else {\n                      handleNodeAdded(curChild);\n                    }\n                } else {\n                  // recursively call for curChild and it's children to see if we find something in\n                  // fromNodesLookup\n                  handleNodeAdded(curChild);\n                }\n\n                curChild = nextSibling;\n            }\n        }\n\n        function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n            // We have processed all of the \"to nodes\". If curFromNodeChild is\n            // non-null then we still have some from nodes left over that need\n            // to be removed\n            while (curFromNodeChild) {\n                var fromNextSibling = curFromNodeChild.nextSibling;\n                if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                    // Since the node is keyed it might be matched up later so we defer\n                    // the actual removal to later\n                    addKeyedRemoval(curFromNodeKey);\n                } else {\n                    // NOTE: we skip nested keyed nodes from being removed since there is\n                    //       still a chance they will be matched up later\n                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                }\n                curFromNodeChild = fromNextSibling;\n            }\n        }\n\n        function morphEl(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (!childrenOnly) {\n                // optional\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                // update attributes on original DOM element first\n                morphAttrs(fromEl, toEl);\n                // optional\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n              morphChildren(fromEl, toEl);\n            } else {\n              specialElHandlers.TEXTAREA(fromEl, toEl);\n            }\n        }\n\n        function morphChildren(fromEl, toEl) {\n            var curToNodeChild = toEl.firstChild;\n            var curFromNodeChild = fromEl.firstChild;\n            var curToNodeKey;\n            var curFromNodeKey;\n\n            var fromNextSibling;\n            var toNextSibling;\n            var matchingFromEl;\n\n            // walk the children\n            outer: while (curToNodeChild) {\n                toNextSibling = curToNodeChild.nextSibling;\n                curToNodeKey = getNodeKey(curToNodeChild);\n\n                // walk the fromNode children all the way through\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n\n                    if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                    var curFromNodeType = curFromNodeChild.nodeType;\n\n                    // this means if the curFromNodeChild doesnt have a match with the curToNodeChild\n                    var isCompatible = undefined;\n\n                    if (curFromNodeType === curToNodeChild.nodeType) {\n                        if (curFromNodeType === ELEMENT_NODE) {\n                            // Both nodes being compared are Element nodes\n\n                            if (curToNodeKey) {\n                                // The target node has a key so we want to match it up with the correct element\n                                // in the original DOM tree\n                                if (curToNodeKey !== curFromNodeKey) {\n                                    // The current element in the original DOM tree does not have a matching key so\n                                    // let's check our lookup to see if there is a matching element in the original\n                                    // DOM tree\n                                    if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                        if (fromNextSibling === matchingFromEl) {\n                                            // Special case for single element removals. To avoid removing the original\n                                            // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                            // we will instead discard the current node and wait until the next\n                                            // iteration to properly match up the keyed target element with its matching\n                                            // element in the original tree\n                                            isCompatible = false;\n                                        } else {\n                                            // We found a matching keyed element somewhere in the original DOM tree.\n                                            // Let's move the original DOM node into the current position and morph\n                                            // it.\n\n                                            // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                            // the `removeNode()` function for the node that is being discarded so that\n                                            // all lifecycle hooks are correctly invoked\n                                            fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                            // fromNextSibling = curFromNodeChild.nextSibling;\n\n                                            if (curFromNodeKey) {\n                                                // Since the node is keyed it might be matched up later so we defer\n                                                // the actual removal to later\n                                                addKeyedRemoval(curFromNodeKey);\n                                            } else {\n                                                // NOTE: we skip nested keyed nodes from being removed since there is\n                                                //       still a chance they will be matched up later\n                                                removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                            }\n\n                                            curFromNodeChild = matchingFromEl;\n                                        }\n                                    } else {\n                                        // The nodes are not compatible since the \"to\" node has a key and there\n                                        // is no matching keyed node in the source tree\n                                        isCompatible = false;\n                                    }\n                                }\n                            } else if (curFromNodeKey) {\n                                // The original has a key\n                                isCompatible = false;\n                            }\n\n                            isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                            if (isCompatible) {\n                                // We found compatible DOM elements so transform\n                                // the current \"from\" node to match the current\n                                // target DOM node.\n                                // MORPH\n                                morphEl(curFromNodeChild, curToNodeChild);\n                            }\n\n                        } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                            // Both nodes being compared are Text or Comment nodes\n                            isCompatible = true;\n                            // Simply update nodeValue on the original node to\n                            // change the text value\n                            if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                            }\n\n                        }\n                    }\n\n                    if (isCompatible) {\n                        // Advance both the \"to\" child and the \"from\" child since we found a match\n                        // Nothing else to do as we already recursively called morphChildren above\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    // No compatible match so remove the old node from the DOM and continue trying to find a\n                    // match in the original DOM. However, we only do this if the from node is not keyed\n                    // since it is possible that a keyed node might match up with a node somewhere else in the\n                    // target tree and we don't want to discard it just yet since it still might find a\n                    // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                    // that didn't find a home\n                    if (curFromNodeKey) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n\n                    curFromNodeChild = fromNextSibling;\n                } // END: while(curFromNodeChild) {}\n\n                // If we got this far then we did not find a candidate match for\n                // our \"to node\" and we exhausted all of the children \"from\"\n                // nodes. Therefore, we will just append the current \"to\" node\n                // to the end\n                if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                    fromEl.appendChild(matchingFromEl);\n                    // MORPH\n                    morphEl(matchingFromEl, curToNodeChild);\n                } else {\n                    var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                    if (onBeforeNodeAddedResult !== false) {\n                        if (onBeforeNodeAddedResult) {\n                            curToNodeChild = onBeforeNodeAddedResult;\n                        }\n\n                        if (curToNodeChild.actualize) {\n                            curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                        }\n                        fromEl.appendChild(curToNodeChild);\n                        handleNodeAdded(curToNodeChild);\n                    }\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n            }\n\n            cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphChildren(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    if (morphedNode.nodeValue !== toNode.nodeValue) {\n                        morphedNode.nodeValue = toNode.nodeValue;\n                    }\n\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n                return;\n            }\n\n            morphEl(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nexport default morphdom;\n","//  This code is ported from\n//  <https://github.com/RobertElderSoftware/roberteldersoftwarediff/>\n//\n//  The license for the original code is:\n//\n//  Copyright 2017 Robert Elder Software Inc.\n//\n//  Licensed under the Apache License, Version 2.0 (the \"License\");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an \"AS IS\" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.import random\n\nimport { zip } from './util'\n\nexport function diff<T, U>(\n  left: ArrayLike<T>,\n  right: ArrayLike<U>,\n  compare: (t: T, u: U) => boolean,\n  match: (pairs: Iterable<[T, U]>) => void,\n): void {\n  const slices: [any[], any[]][] = []\n  function go(e: Array<T>, f: Array<U>, i = 0, j = 0): void {\n    // Adapted from http://blog.robertelder.org/diff-algorithm/\n    // Licensed under Apache 2.0\n    const [N, M, L, Z] = [\n      e.length,\n      f.length,\n      e.length + f.length,\n      2 * Math.min(e.length, f.length) + 2,\n    ]\n    if (N > 0 && M > 0) {\n      const [w, g, p] = [\n        N - M,\n        Array(Z).fill(0) as number[],\n        Array(Z).fill(0) as number[],\n      ]\n      for (let h = 0; h < L / 2 + (L % 2) + 1; h++) {\n        for (let r = 0; r < 2; r++) {\n          const [c, d, o, m] = r === 0 ? [g, p, 1, 1] : [p, g, 0, -1]\n          for (\n            let k = -(h - 2 * Math.max(0, h - M));\n            k < h - 2 * Math.max(0, h - N) + 1;\n            k += 2\n          ) {\n            let a =\n              k === -h || (k !== h && c[(k - 1) % Z] < c[(k + 1) % Z])\n                ? c[(k + 1) % Z]\n                : c[(k - 1) % Z] + 1\n            let b = a - k\n            const [s, t] = [a, b]\n            while (\n              a < N &&\n              b < M &&\n              compare(\n                e[(1 - o) * N + m * a + (o - 1)],\n                f[(1 - o) * M + m * b + (o - 1)],\n              )\n            ) {\n              a++, b++\n            }\n            c[k % Z] = a\n            const z = -(k - w)\n            if (\n              L % 2 === o &&\n              z >= -(h - o) &&\n              z <= h - o &&\n              c[k % Z] + d[z % Z] >= N\n            ) {\n              const [D, x, y, u, v] =\n                o === 1\n                  ? [2 * h - 1, s, t, a, b]\n                  : [2 * h, N - a, M - b, N - s, M - t]\n              if (D > 1 || (x !== u && y !== v)) {\n                if (x !== u && y !== v) {\n                  slices.push([e.slice(x, u), f.slice(y, v)])\n                }\n                // return go(e.slice(0, x), f.slice(0, y), i, j).concat(\n                //   go(e.slice(u, N), f.slice(v, M), i + u, j + v),\n                go(e.slice(0, x), f.slice(0, y), i, j)\n                go(e.slice(u, N), f.slice(v, M), i + u, j + v)\n                return\n              } else if (M > N) {\n                slices.push([e.slice(0, N), f.slice(0, N)])\n                return\n                // return go([], f.slice(N, M), i + N, j + N)\n              } else if (M < N) {\n                slices.push([e.slice(0, M), f.slice(0, M)])\n                return\n                // return go(e.slice(M, N), [], i + M, j + M)\n              } // else return []\n            }\n          }\n        }\n      }\n    } /* else if (N > 0) {\n      console.log('delete', e)\n      return\n    } else {\n      console.log('insert', e)\n    }*/\n  }\n  go(Array.from(left), Array.from(right))\n  match(slicesToItems(slices))\n}\n\nfunction* slicesToItems(slices: [any[], any[]][]) {\n  for (const [a, b] of slices) {\n    yield* zip(a, b)\n  }\n}\n","export function handlePromise(promise: Promise<any>): void {\n  if (!promise) return\n  promise.catch((error: Error) => {\n    console.error(error)\n  })\n}\nimport { lstatSync, existsSync } from 'fs'\nexport function isFileSync(filePath: string) {\n  if (!existsSync(filePath)) return false\n  return lstatSync(filePath).isFile()\n}\n\nexport function resolveElement(\n  root: Element,\n  pathToToken: Array<{ tag: string; index: number }>,\n): Element | undefined {\n  let element = root\n  for (const token of pathToToken) {\n    const candidateElement: HTMLElement | null = element\n      .querySelectorAll(`:scope > ${token.tag}`)\n      .item(token.index) as HTMLElement\n    if (candidateElement) {\n      element = candidateElement\n    } else {\n      break\n    }\n  }\n\n  if (element === root) return undefined // Do not jump to the top of the preview for bad syncs\n  return element\n}\n\nexport function* zip<U, V>(\n  a: Iterable<U>,\n  b: Iterable<V>,\n): IterableIterator<[U, V]> {\n  const ita = a[Symbol.iterator]()\n  const itb = b[Symbol.iterator]()\n  let x = ita.next()\n  let y = itb.next()\n  while (!x.done && !y.done) {\n    yield [x.value, y.value]\n    x = ita.next()\n    y = itb.next()\n  }\n}\n","//\n// mathjax-helper\n//\n// This module will handle loading the MathJax environment and provide a wrapper\n// for calls to MathJax to process LaTeX equations.\n//\n\nexport function processHTMLString(element: Element) {\n  const msvgh = document.getElementById('MathJax_SVG_Hidden')\n  const svgGlyphs = msvgh && msvgh.parentElement\n  if (svgGlyphs !== null) {\n    return svgGlyphs.outerHTML + element.innerHTML\n  } else {\n    return element.innerHTML\n  }\n}\n\nexport class MathJaxController {\n  private static mjSrc = `${global.require.resolve(\n    'mathjax',\n  )}?delayStartupUntil=configured`\n  private readonly readyPromise: Promise<void>\n\n  private constructor(\n    private userMacros: object,\n    private mathJaxConfig: MathJaxConfig,\n  ) {\n    this.readyPromise = this.attachMathJax()\n  }\n\n  public static async create(userMacros: object, mathJaxConfig: MathJaxConfig) {\n    const controller = new MathJaxController(userMacros, mathJaxConfig)\n    await controller.readyPromise\n    return controller\n  }\n\n  // for testing\n  public dispose(): void {\n    const script = document.head!.querySelector(\n      `script[src='${MathJaxController.mjSrc}']`,\n    )\n    if (script) script.remove()\n  }\n\n  public jaxTeXConfig() {\n    return {\n      extensions: this.mathJaxConfig.texExtensions,\n      Macros: this.userMacros,\n      equationNumbers: this.mathJaxConfig.numberEquations\n        ? {\n            autoNumber: 'AMS',\n            useLabelIds: false,\n          }\n        : {},\n    }\n  }\n\n  public async queueTypeset(domElement: Element) {\n    const allMath = Array.from(\n      domElement.querySelectorAll('span.math > script[type^=\"math/tex\"]'),\n    )\n    const unprocessedMath = allMath.filter((x) => {\n      const jax = MathJax.Hub.getJaxFor(x) as MathJax.ElementJax | null\n      try {\n        return !jax || x.id !== jax.inputID || jax.needsUpdate()\n      } catch (e) {\n        console.error(e)\n        return true\n      }\n    })\n    if (unprocessedMath.length === 0) return\n    return new Promise<void>((resolve) => {\n      if (MathJax.InputJax.TeX) {\n        MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX])\n      }\n      const { temps, spans } = this.setupTemps(allMath)\n      MathJax.Hub.Queue(['PreProcess', MathJax.Hub, temps])\n      MathJax.Hub.Queue(['Reprocess', MathJax.Hub, temps])\n      MathJax.Hub.Queue(() => this.cleanupTemps(temps, spans))\n      MathJax.Hub.Queue([resolve])\n    })\n  }\n\n  private cleanupTemps(temps: HTMLElement[], spans: HTMLElement[]) {\n    for (const span of spans) span.remove()\n    for (const temp of temps) {\n      temp.style.visibility = ''\n      temp.style.position = ''\n      temp.style.width = ''\n      temp.style.display = ''\n      temp.classList.remove('temp-MathJax')\n    }\n  }\n\n  private setupTemps(scriptElements: Element[]) {\n    const temps: HTMLElement[] = []\n    const spans: HTMLElement[] = []\n    for (const script of scriptElements) {\n      const span = script.parentElement\n      if (!span) continue\n      const par = span.parentElement\n      if (!par) continue\n      const disp = script.previousElementSibling\n      if (disp) {\n        // update render\n        const temp = span.cloneNode(false) as HTMLSpanElement\n        temp.classList.add('temp-MathJax')\n        temp.appendChild(script.cloneNode(true))\n        temps.push(temp)\n        spans.push(span)\n        par.insertBefore(temp, span)\n        temp.style.visibility = 'hidden'\n        temp.style.position = 'absolute'\n        if ((script as HTMLScriptElement).type.includes('display')) {\n          temp.style.width = window.getComputedStyle(disp).width\n          temp.style.display = 'block'\n        }\n      } else {\n        // initial render\n        temps.push(span)\n      }\n    }\n    return { temps, spans }\n  }\n\n  private async attachMathJax(): Promise<void> {\n    // Attach MathJax script\n    await injectScript(MathJaxController.mjSrc)\n\n    MathJax.Hub.Config({\n      jax: ['input/TeX', `output/${this.mathJaxConfig.latexRenderer}`],\n      extensions: [],\n      TeX: this.jaxTeXConfig(),\n      'HTML-CSS': {\n        availableFonts: [],\n        webFont: 'TeX',\n        imageFont: null as any, // TODO: complain on DT\n        undefinedFamily: this.mathJaxConfig.undefinedFamily as any, // TODO: complain on DT\n        mtextFontInherit: true,\n      },\n      messageStyle: 'none',\n      showMathMenu: false,\n      skipStartupTypeset: true,\n    })\n    MathJax.Hub.Configured()\n  }\n}\n\nasync function injectScript(scriptSrc: string) {\n  const script = document.createElement('script')\n  script.src = scriptSrc\n  script.type = 'text/javascript'\n  document.head!.appendChild(script)\n  return new Promise<void>((resolve) => {\n    script.addEventListener('load', () => resolve())\n  })\n}\n","export function getMedia(document: HTMLDocument) {\n  return document.querySelectorAll(\n    'img[src],audio[src],video[src],link[href]',\n  ) as NodeListOf<\n    HTMLImageElement | HTMLAudioElement | HTMLVideoElement | HTMLLinkElement\n  >\n}\n"],"names":["$parcel$global","globalThis","self","window","global","$df1b9f42350d717d811e51c981b04f8$var$_electron","_electron","async","oldDom","newDom","opts","idMap","WeakMap","diffMethod","time","idx","matchEls","newRoot","oldRoot","newEl","firstChild","oldEl","newCount","childNodes","length","oldCount","isEqual","nodeType","Node","ELEMENT_NODE","sidx","toString","set","nextSibling","runHeuristic","a","Array","from","allChildren","b","ncomp","$c3d4abd0c0642e0306498ca239f63864$exports","diff","pairs","x","y","console","log","$fd18aa23dbb1266ae527f42230c23$var$_morphdom","default","childrenOnly","onBeforeElUpdated","fromEl","toEl","isEqualNode","tcs","getMathContents","textContent","getNodeKey","node","get","e","error","innerHTML","renderLaTeX","mjController","queueTypeset","Object","defineProperty","value","range","doc","document","undefined","HAS_TEMPLATE_SUPPORT","createElement","HAS_RANGE_SUPPORT","createRange","toElement","str","trim","template","content","createFragmentFromTemplate","selectNode","body","createContextualFragment","createFragmentFromRange","fragment","createFragmentFromWrap","compareNodeNames","fromCodeStart","toCodeStart","fromNodeName","nodeName","toNodeName","charCodeAt","toUpperCase","syncBooleanAttrProp","name","setAttribute","removeAttribute","specialElHandlers","OPTION","parentNode","parentName","hasAttribute","selected","selectedIndex","INPUT","TEXTAREA","newValue","oldValue","nodeValue","placeholder","SELECT","optgroup","i","curChild","noop","defaultGetNodeKey","getAttribute","id","morphAttrs","morphdom","fromNode","toNode","attr","attrName","attrNamespaceURI","attrValue","toNodeAttrs","attributes","namespaceURI","localName","getAttributeNS","prefix","setAttributeNS","fromNodeAttrs","d","hasAttributeNS","removeAttributeNS","options","toNodeHtml","onBeforeNodeAdded","onNodeAdded","onElUpdated","onBeforeNodeDiscarded","onNodeDiscarded","onBeforeElChildrenUpdated","fromNodesLookup","create","keyedRemovalList","addKeyedRemoval","key","push","removeNode","skipKeyedNodes","removeChild","walkDiscardedChildNodes","handleNodeAdded","el","unmatchedFromEl","replaceChild","morphEl","toElKey","curToNodeKey","curFromNodeKey","fromNextSibling","toNextSibling","matchingFromEl","curToNodeChild","curFromNodeChild","outer","isSameNode","curFromNodeType","isCompatible","insertBefore","appendChild","onBeforeNodeAddedResult","actualize","ownerDocument","cleanupFromEl","specialElHandler","morphChildren","indexTree","morphedNode","morphedNodeType","toNodeType","nextChild","moveChildren","createElementNS","len","elToRemove","$e730ac64d1f01aff290702b7ff3c8beb$exports","left","right","compare","match","slices","go","f","j","N","M","L","Z","Math","min","w","g","p","fill","h","r","c","o","m","k","max","s","t","z","D","u","v","slice","$be99a8afe96dba9f1fbb6da82e23c4d0$exports","zip","slicesToItems","promise","catch","filePath","$be99a8afe96dba9f1fbb6da82e23c4d0$var$_fs","existsSync","lstatSync","isFile","root","pathToToken","element","token","candidateElement","querySelectorAll","tag","item","index","ita","Symbol","iterator","itb","next","done","_fs","isElement","tagName","classList","contains","ascr","querySelector","bscr","type","isEqualMath","ac","bc","DOCUMENT_TYPE_NODE","publicId","systemId","checkDocumentType","every","getNamedItemNS","checkElement","ATTRIBUTE_NODE","checkAttr","PROCESSING_INSTRUCTION_NODE","target","data","checkProcInstr","TEXT_NODE","COMMENT_NODE","checkData","children","cb","start","performance","now","res","msvgh","getElementById","svgGlyphs","parentElement","outerHTML","MathJaxController","[object Object]","require","resolve","constructor","userMacros","mathJaxConfig","this","readyPromise","attachMathJax","controller","dispose","script","head","mjSrc","remove","jaxTeXConfig","extensions","texExtensions","Macros","equationNumbers","numberEquations","autoNumber","useLabelIds","domElement","allMath","filter","jax","MathJax","Hub","getJaxFor","inputID","needsUpdate","Promise","InputJax","TeX","Queue","temps","spans","setupTemps","cleanupTemps","span","temp","style","visibility","position","width","display","scriptElements","par","disp","previousElementSibling","cloneNode","add","includes","getComputedStyle","scriptSrc","src","addEventListener","injectScript","Config","latexRenderer","HTML-CSS","availableFonts","webFont","imageFont","undefinedFamily","mtextFontInherit","messageStyle","showMathMenu","skipStartupTypeset","Configured","$df1b9f42350d717d811e51c981b04f8$var$util","$df1b9f42350d717d811e51c981b04f8$var$_interopRequireWildcard","handlerId","nativePageScrollKeys","uncaughtError","err","ipcRenderer","send","message","stack","evt","reason","atomVars","mathJax","resFn","mkResPromise","sourceLineMap","Map","revSourceMap","scrollSync","firstLine","lastLine","scroll","top","slm","lines","keys","sort","lowix","findIndex","highix","low","high","norm","meanScroll","entries","line","weight","getBoundingClientRect","documentElement","scrollTop","clientHeight","updatePromise","nextUpdateParams","doUpdate","html","map","scrollSyncParams","preview","domDocument","DOMParser","parseFromString","hasChildNodes","container","firstElementChild","headElement","visibleElements","innerHeight","bottom","$fd18aa23dbb1266ae527f42230c23$exports","update","stillVisibleElements","offsetParent","lastEl","scrollBy","slsm","rsm","lineS","path","parseInt","elem","util","resolveElement","rsmel","request","result","$ae213629d5aa5eb47e5246db3f9063f3$exports","processHTMLString","delayedUpdate","then","on","_evt","params","dataset","markdownPreviewPlusContext","context","setProperty","pdfExportOptions","val","_event","styles","styleElem","join","oldsrc","imgs","$a95a41a7be3a6d49f1d792f14cf7f3fd$exports","getMedia","img","ovs","ov","flash","scrollIntoViewIfNeeded","setTimeout","readyState","loaded","removeEventListener","baseElement","keyEventHandler","altKey","ctrlKey","shiftKey","metaKey","code","bubbles","cancelable","composed","detail","isComposing","location","repeat","preventDefault","lastContextMenuTarget","href","msg","errorDiv","event","deltaY","stopPropagation","height","visible","_line","_elem","bind","_","onbeforeunload","selection","getSelection","selectedText","selectedNode","anchorNode","startsWith","anchor","decodeURIComponent","scrollIntoView"],"version":3,"file":"main.js.map"}